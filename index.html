<html>
<head>
<meta charset="utf-8" />
<title>STL Knob Designer</title>
<style>
html {
    font-size:14px;
    margin:0;
}
body {
    background:#1f243a;
    color:#e0e0e0;
    margin:0;
    padding:2px 15px;
}
td {
    font-size: 13.5px;
    border: 1px solid #668;
    padding:0px 5px;
}
canvas {
    border:1px solid #666666;
    width:480px;
    height:480px;
}
h1 {
    margin:auto 20px;
}
.param {
    vertical-align: middle;
    height:18px;
    width:60px;
}
.paramcolor {
    width:60px;
    height:20px;
    text-align: center;
    font-size:12px;
    background:#000;
    color:#fff;
    border:none;
}
#header {
    display:flex;
    margin:20px;
    background:#445;
    color:#ccf;
    margin:0px 5px;
}
#header a {
    color:#ccf;
}
#main {
    position:relative;
    margin:10px auto;
    width:1050px;
    border:1px solid #666;
    padding:1px 10px;
}
#knobrot {
    position:absolute;
    left:5px;
    bottom:5px;
    width:200px;
}
#aboutpane {
    display:none;
    position:absolute;
    left:50%;
    top:0;
    background:rgba(0,0,0,0.5);
    width:100%;
    height:100%;
    transform: translate(-50%, 0);
}
#about {
    position:relative;
    background:#ccf;
    width:80%;
    height:80%;
    margin:auto;
    top:20px;
    color:#1f243a;
    padding:20px;
    overflow-y: scroll;
}
#aboutcontent {
    color:#1f243a;
    background:#ccf;
}
#aboutcontent td {
    color:#000;
}
#aboutclose {
    position:absolute;
    right:20px;
    bottom:20px 80px;
}
</style>
<body>
<div id="header">
    <img src="images/g200kg160x80.png"/>
    <div>
    <h1>STL Knob Designer</h1>
    <p style="margin:0px 50px">v<span id="version"></span> g200kg</p>
    <p style="margin:0px 50px">Repository : <a href="https://github.com/g200kg/stl-knob-designer" target="_blank">https://github.com/g200kg/stl-knob-designer</a></p>
    </div>
</div>
<div id="main">
    <button onclick="app.export()">Export as STL</button>
    <button onclick="app.save()">Save Param (JSON)</button>
    <button onclick="app.load()">Load Param (JSON)</button>
    <button onclick="app.saveDefault()">Save Default</button>
    <button onclick="app.about()">About</button>
<div style="display:flex">
<div style="position:relative">
    <canvas id="canvas" ></canvas>
    <webaudio-slider id="knobrot" defvalue="0" min="-145" max="145" oninput="app.rotate(this)"></webaudio-slider>
</div>
<div style="height:630px;overflow-y:scroll">
    <div>
    <table>
        <tr><td rowspan="3"><webaudio-switch id="shaftEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="3">SHAFT</td><td>Type</td><td colspan="2"><select id="shaftType" onchange="editParam(this)">
        </select></td></tr>
        <tr><td>FineAdjust(%)</td><td><webaudio-slider id="shaftFineAdj" oninput="editParam(this)" min="-5" max="5" step="0.1"></webaudio-slider></td><td><webaudio-param link="shaftFineAdj"></webaudio-param></td></tr>
        <tr><td>Rotate(deg)</td><td><webaudio-slider id="shaftRotate" oninput="editParam(this)" min="-180" max="180" step="15"></webaudio-slider></td><td><webaudio-param link="shaftRotate"></webaudio-param></td></tr>

        <tr><td rowspan="5"><webaudio-switch id="topEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="5">TOP</td><td>Subdivide</td><td><webaudio-slider id="topSubdiv" oninput="editParam(this)" min="3" max="72" step="1"></webaudio-slider></td><td><webaudio-param link="topSubdiv"></webaudio-param></td></tr>
        <tr><td>TopDiameter(%)</td><td><webaudio-slider id="topTopDiameter" oninput="editParam(this)" min="0" max="100" step="1"></webaudio-slider></td><td><webaudio-param link="topTopDiameter"></webaudio-param></td></tr>
        <tr><td>BottomDiameter(%)</td><td><webaudio-slider id="topBottomDiameter" oninput="editParam(this)" min="0" max="100" step="1"></webaudio-slider></td><td><webaudio-param link="topBottomDiameter"></webaudio-param></td></tr>
        <tr><td>Height(mm)</td><td><webaudio-slider id="topHeight" oninput="editParam(this)" min="0" max="10" step="0.1"></webaudio-slider></td><td><webaudio-param link="topHeight"></webaudio-param></td></tr>
        <tr><td>Color</td><td><input type="color" id="topColor" oninput="editParam(this)"/></td><td><input id="topColorInput" class="paramcolor" onchange="editParam(this)"/></td></tr>

        <tr><td rowspan="10"><webaudio-switch id="bodyEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="10">BODY</td><td>Subdivide</td><td><webaudio-slider id="bodySubdiv" oninput="editParam(this)" min="3" max="180" step="1"></webaudio-slider></td><td><webaudio-param link="bodySubdiv"></webaudio-param></td></tr>
        <tr><td>TopDiameter(%)</td><td><webaudio-slider id="bodyTopDiameter" oninput="editParam(this)" min="0" max="200" step="1"></webaudio-slider></td><td><webaudio-param link="bodyTopDiameter"></webaudio-param></td></tr>
        <tr><td>TopBevel(mm)</td><td><webaudio-slider id="bodyTopBevel" oninput="editParam(this)" min="0" max="5.0" step="0.1"></webaudio-slider></webaudio-slider></td><td><webaudio-param link="bodyTopBevel"></webaudio-param></td></tr>
        <tr><td>BottomDiameter(mm)</td><td><webaudio-slider id="bodyBottomDiameter" oninput="editParam(this)" min="10" max="50" step="0.1"></webaudio-slider></td><td><webaudio-param link="bodyBottomDiameter"></webaudio-param></td></tr>
        <tr><td>Height(mm)</td><td><webaudio-slider id="bodyHeight" oninput="editParam(this)" min="11" max="50" step="0.1"></webaudio-slider></td><td><webaudio-param link="bodyHeight"></webaudio-param></td></tr>
        <tr><td>KnurlForm</td><td><webaudio-slider id="bodyKnurlForm" oninput="editParam(this)" min="0" max="2" step="1" tracking="abs" conv="['None','Sin','Sqr'][x]"></webaudio-slider></td><td><webaudio-param link="bodyKnurlForm"></webaudio-param></td></tr>
        <tr><td>KnurlNum</td><td><webaudio-slider id="bodyKnurlNum" oninput="editParam(this)" min="0" max="36" step="1"></webaudio-slider></td><td><webaudio-param link="bodyKnurlNum"></webaudio-param></td></tr>
        <tr><td>KnurlDepth(mm)</td><td><webaudio-slider id="bodyKnurlDepth" oninput="editParam(this)" min="-5" max="5" step="0.1"></webaudio-slider></td><td><webaudio-param link="bodyKnurlDepth"></webaudio-param></td></tr>
        <tr><td>KnurlWidth</td><td><webaudio-slider id="bodyKnurlWidth" oninput="editParam(this)" min="-5" max="5" step="0.1"></webaudio-slider></td><td><webaudio-param link="bodyKnurlWidth"></webaudio-param></td></tr>
        <tr><td>Color</td><td><input type="color" id="bodyColor" oninput="editParam(this)"/></td><td><input id="bodyColorInput" class="paramcolor" onchange="editParam(this)"/></td></tr>

        <tr><td rowspan="5"><webaudio-switch id="skirtEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="5">SKIRT</td><td>Subdivide</td><td><webaudio-slider id="skirtSubdiv" oninput="editParam(this)" min="3" max="72" step="1"></webaudio-slider></td><td><webaudio-param link="skirtSubdiv"></webaudio-param></td></tr>
        <tr><td>Diameter(Body+mm)</td><td><webaudio-slider id="skirtDiameter" oninput="editParam(this)" min="0" max="10.0" step="0.1"></webaudio-slider></td><td><webaudio-param link="skirtDiameter"></webaudio-param></td></tr>
        <tr><td>Bevel(mm)</td><td><webaudio-slider id="skirtBevel" oninput="editParam(this)" min="0" max="5.0" step="0.1"></webaudio-slider></td><td><webaudio-param link="skirtBevel"></webaudio-param></td></tr>
        <tr><td>Height(mm)</td><td><webaudio-slider id="skirtHeight" oninput="editParam(this)" min="0" max="10" step="0.1"></webaudio-slider></td><td><webaudio-param link="skirtHeight"></webaudio-param></td></tr>
        <tr><td>Color</td><td><input type="color" id="skirtColor" oninput="editParam(this)"/></td><td><input id="skirtColorInput" class="paramcolor" onchange="editParam(this)"/></td></tr>

        <tr><td rowspan="4"><webaudio-switch id="pointerEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="4">POINTER</td><td>Length(mm)</td><td><webaudio-slider id="pointerLength" oninput="editParam(this)" min="0" max="10" step="0.1"></webaudio-slider></td><td><webaudio-param link="pointerLength"></webaudio-param></td></tr>
        <tr><td>Width(mm)</td><td><webaudio-slider id="pointerWidth" oninput="editParam(this)" min="0.5" max="5.0" step="0.1"></webaudio-slider></td><td><webaudio-param link="pointerWidth"></webaudio-param></td></tr>
        <tr><td>Height(mm)</td><td><webaudio-slider id="pointerHeight" oninput="editParam(this)" min="0" max="5.0" step="0.1"></webaudio-slider></td><td><webaudio-param link="pointerHeight"></webaudio-param></td></tr>
        <tr><td>Bevel(mm)</td><td><webaudio-slider id="pointerBevel" oninput="editParam(this)" min="0" max="5.0" step="0.1"></webaudio-slider></td><td><webaudio-param link="pointerBevel"></webaudio-param></td></tr>
    </table>
    </div>
    </div>
</div>
<div id="aboutpane">
<div id="about">
<div>
<div id="aboutcontent">
<h2>STL Knob Designer</h2>

<p>This is a program that generates STL files of potentiometer-knobs for 3D printers. The potentiometer should be a 6mm diameter 15mm long, knurled shaft .</p>

<p>If your printer can output '3DBenchy' model fine without supports, you don't need to add supports.</p>

<p>This program assuming use with an FDM machine, and a slightly elastic filament such as PETG rather than PLA. Also, depending on the printer model, settings and filament type, it may be necessary to fine-tune the fit with the shaft.</p>

<p>The fitting to the shaft can be fine-tuned with [SHAFT]-[FineAdject].</p>

<p>The color setting is not reflected in the STL file, you can pause at a specific layer in the slicer and manually swap filaments.</p>

----

<p>これは 3D プリンタで造形可能なツマミの STL ファイルを生成するプログラムです。6mm 径の 15mm 長、ローレット軸のシャフトを持つポテンショメータ用のツマミのデータを生成します。  </p>

<p>FDM 機での使用を想定しており、フィラメントは PLA よりも PETG 等の多少の弾力性のある材料を推奨します。</p>

<p>サポート無しで '3DBenchy' くらいがちゃんと造形できているのであれば、サポートの追加は必要ありません。
またプリンタの機種やフィラメントの種類によってプリンタの印刷設定等で、軸との篏合を微調整する必要があるかもしれません。</p>

<p>シャフトとの篏合の硬さは [SHAFT]-[FineAdjust] で微調整できます。</p>

<p>色の設定は STL ファイルには反映されませんが、スライサーで TOP 部が始まるレイヤーを確認して、そこでプリンターを一時停止して、フィラメントを手動で入れ替えるなどの手段を取る事ができます。</p>

<hr/>
g200kg
</div>
</div>
<button id="aboutclose" onclick="document.getElementById('aboutpane').style.display='none'">Close</button>
</div>
</div>
</div>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.142.0/build/three.module",
            "three/": "https://unpkg.com/three@0.142.0/",
            "three/addons/": "https://unpkg.com/three@0.142.0/examples/jsm/"
        }
    }
</script>
<script>
    WebAudioControlsOptions={
        switchHeight:28,
        sliderWidth:180,
        paramWidth:60
    }
</script>
<script src="https://g200kg.github.io/webaudio-controls/webaudio-controls.js"></script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { STLLoader } from "three/examples/jsm/loaders/STLLoader";
import { STLExporter } from 'three/addons/exporters/STLExporter.js';

const shaftFiles = [
    "Shaft_Knurled",
    "Shaft_D",
];
const paramDefault = {
    program: "STLKnobDesigner",
    version: "0.3.1",
    params: {
        shaftEnable: 1,
        shaftType: shaftFiles[0],
        shaftFineAdj: 0,
        shaftRotate: 0,
        topEnable: 1,
        topSubdiv: 36,
        topTopDiameter: 80,
        topBottomDiameter: 80,
        topHeight: 1.0,
        topColor: "#ff0000",
        bodyEnable: 1,
        bodySubdiv: 72,
        bodyKnurlForm: 1,
        bodyKnurlNum: 12,
        bodyKnurlDepth: 0.6,
        bodyKnurlWidth: 0,
        bodyTopDiameter: 80,
        bodyTopBevel: 0.5,
        bodyBottomDiameter: 15.0,
        bodyHeight: 15.0,
        bodyColor: "#ffffff",
        skirtEnable: 1,
        skirtSubdiv: 36,
        skirtDiameter: 5.0,
        skirtBevel: 0.5,
        skirtHeight: 2.0,
        skirtColor: "#ffffff",
        pointerEnable: 1,
        pointerLength: 2.0,
        pointerWidth: 1.5,
        pointerHeight: 2.0,
        pointerBevel: 1.2,
    }
};

const paramCurrent = Object.assign({}, JSON.parse(JSON.stringify(paramDefault)));

class Rectangular {
    constructor() {
        this.geo = new THREE.BufferGeometry();
        this.layers = [];
        this.topBevel = 0.5;
    }
    clear() {
        this.layers = [];
    }
    addRect(layer) {
        this.layers.push(layer);
    }
    createGeo() {
        const vtx = [];
        const indices = [];
        for(let l=0; l < this.layers.length; ++l) {
            const layer = this.layers[l];
            vtx.push(layer.x1, layer.y1, layer.z);
            vtx.push(layer.x2, layer.y1, layer.z);
            vtx.push(layer.x1, layer.y2, layer.z);
            vtx.push(layer.x2, layer.y2, layer.z);
        }
        this.vertices = new Float32Array(vtx);
        indices.push(1, 0, 2);
        indices.push(1, 2, 3);
        let vb = 0;
        for(let l=1; l < this.layers.length; ++l, vb+=4) {
            indices.push(vb+0, vb+5, vb+4);
            indices.push(vb+1, vb+5, vb+0);
            indices.push(vb+2, vb+0, vb+4);
            indices.push(vb+2, vb+4, vb+6);
            indices.push(vb+5, vb+1, vb+7);
            indices.push(vb+7, vb+1, vb+3);
            indices.push(vb+3, vb+2, vb+6);
            indices.push(vb+7, vb+3, vb+6);
        }
        indices.push(vb+0, vb+1, vb+2);
        indices.push(vb+2, vb+1, vb+3);
        this.geo.setIndex(indices);
        this.geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vtx), 3));
        this.geo.computeVertexNormals();
        return this.geo;
    }
}
class Tube {
    constructor() {
        this.geo = new THREE.BufferGeometry();
        this.layers = [];
    }
    clear() {
        this.layers = [];
    }
    wave(th) {
        const p = paramCurrent.params;
        switch(p.bodyKnurlForm) {
        case 0:
            return 0;
        case 1:
            return Math.pow((1+Math.cos(th))*0.5, Math.pow(2, -p.bodyKnurlWidth));
        case 2:
            const t = Math.pow((1+Math.cos(th))*0.5, Math.pow(2, -p.bodyKnurlWidth));
            if(t>=0.5) return 1;
            return 0;
        }
    }
    knurling(th) {
        return this.wave(th);
    }
    addCircle(layer) {
        this.layers.push(layer);
    }
    createGeo(divr, knurlNum, knurlDepth, knurlType) {
        this.geo = new THREE.BufferGeometry();
        const vtx = [];
        const indices = [];
        for(let l=0; l < this.layers.length; ++l) {
            const r1 = this.layers[l].r1;
            const r2 = this.layers[l].r2;
            const z = this.layers[l].z;
            for(let i = 0; i < divr; ++i) {
                const th = 2*Math.PI*i/divr;
                const kd = knurlDepth * this.knurling(th * knurlNum);
                const x = Math.sin(th);
                const y = Math.cos(th);
                vtx.push(x * (r1 + kd), y * (r1 + kd), z);
                vtx.push(x * r2, y * r2, z);
            }
        }
        this.vertices = new Float32Array(vtx);
        let vtxbase;
        const vtxmax = divr*2;
        for(let i = 0; i < divr; ++i){
            const j = i * 2;
            const j2 = (j+2)%vtxmax;
            const j3 = (j+3)%vtxmax;
            indices.push(j2, j+1, j);
            indices.push(j+1, j2, j3);
        }
        for(let l = 0; l < this.layers.length-1; ++l) {
            vtxbase = l*divr*2;
            for(let i = 0; i < divr; ++i) {
                const j = i * 2;
                const j2 = (j+2)%vtxmax;
                indices.push(j+vtxbase, j+divr*2+vtxbase, ((j+2)%vtxmax)+vtxbase);
                indices.push(((j+2)%vtxmax)+vtxbase, j+divr*2+vtxbase, j2+divr*2+vtxbase);
                indices.push(j+divr*2+1+vtxbase, j+1+vtxbase, ((j+2)%vtxmax)+1+vtxbase);
                indices.push(j+divr*2+1+vtxbase, ((j+2)%vtxmax)+1+vtxbase, j2+divr*2+1+vtxbase);
            }
        }
        vtxbase = (this.layers.length-1)*divr*2;
        for(let i = 0; i < divr; ++i){
            const j = i * 2 + vtxbase;
            const j2 = (j+2)%vtxmax + vtxbase;
            const j3 = (j+3)%vtxmax + vtxbase;
            indices.push(j, j+1, j2);
            indices.push(j3, j2, j+1);
        }

        this.geo.setIndex(indices);
        this.geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vtx), 3));
        this.geo.computeVertexNormals();
        return this.geo;
    }
}
class Shaft {
    constructor() {
        this.stlLoader = new STLLoader();
        this.meshes = [];
        for(let i = 0; i < shaftFiles.length; ++i) {
            this.stlLoader.load('Shaft/'+shaftFiles[i]+'.stl', (geoShaft)=> {
                this.material = new THREE.MeshPhongMaterial({color: "#fff", flatShading:true});
                this.meshes[shaftFiles[i]] = new THREE.Mesh(geoShaft, this.material);
//                this.meshes[shaftFiles[i]].visible = false;
//                app.scene.add(this.meshes[shaftFiles[i]]);
                this.update();
            });
        }
    }
    update() {
        const p = paramCurrent.params;
/*        for(let i = 0; i < shaftFiles.length; ++i) {
            if(this.meshes[shaftFiles[i]])
                this.meshes[shaftFiles[i]].visible = false;
        }
*/
        if(this.mesh) {
            app.scene.remove(this.mesh);
        }
        this.mesh = this.meshes[p.shaftType];
        if(this.mesh) {
            this.mesh.scale.set(1.0 + p.shaftFineAdj*0.01, 1.0 + p.shaftFineAdj*0.01, 1.0);
            app.scene.add(this.mesh);
            app.rotate();
        }
/*
        app.scene.add(this.meshes[shaftFiles[i]]);
        if(this.meshes[p.shaftType]){
            this.meshes[p.shaftType].scale.set(1.0 + p.shaftFineAdj*0.01, 1.0 + p.shaftFineAdj*0.01, 1.0);
            this.meshes[p.shaftType].visible = !!p.shaftEnable;
            app.rotate();
        }
        */
    }
}
class Top {
    constructor() {
        this.tube = new Tube();
        this.geo = null;
        this.mesh = null;
        this.material = null;
    }
    getGeo() {
        const p = paramCurrent.params;
        this.tube.clear();
        this.tube.addCircle({r1:(p.bodyBottomDiameter * p.bodyTopDiameter*0.01 * p.topBottomDiameter*0.01)*0.5, r2:0, z:p.bodyHeight});
        this.tube.addCircle({r1:(p.bodyBottomDiameter * p.bodyTopDiameter*0.01 * p.topBottomDiameter*0.01) * p.topTopDiameter*0.01 *0.5, r2:0, z:p.bodyHeight+p.topHeight});
        this.geo = this.tube.createGeo(p.topSubdiv, 0, 0);
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh) {
            app.scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
        }
        this.getGeo();
        this.material = new THREE.MeshPhongMaterial({color: p.topColor, flatShading:true});
        this.mesh = new THREE.Mesh(this.geo, this.material);
        this.mesh.visible = !!p.topEnable;
        app.scene.add(this.mesh);
    }
}
class Lid {
    constructor() {
        this.tube = new Tube();
        this.geo = null;
        this.mesh = null;
        this.material = null;
        this.subdiv = paramCurrent.params.bodySubdiv;
    }
    getGeo() {
        const p = paramCurrent.params;
        this.tube.clear();
        this.tube.addCircle({r1:5.8, r2:0, z:10.0});
        this.tube.addCircle({r1:5.8, r2:0, z:p.bodyHeight});
        this.geo = this.tube.createGeo(this.subdiv, 0, 0);
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh) {
            app.scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
        }
        this.getGeo();
        this.material = new THREE.MeshPhongMaterial({color: p.bodyColor, flatShading:true});
        this.mesh = new THREE.Mesh(this.geo, this.material);
        app.scene.add(this.mesh);
    }
}
class Body {
    constructor() {
        this.tube = new Tube();
        this.geo = null;
        this.mesh = null;
        this.material = null;
    }
    getGeo() {
        const p = paramCurrent.params;
        const topDia = (p.bodyBottomDiameter * p.bodyTopDiameter*0.01)*0.5;
        this.tube.clear();
        this.tube.addCircle({r1:p.bodyBottomDiameter*0.5, r2:5.8, z:0.0});
        this.tube.addCircle({r1:topDia, r2:5.8, z:p.bodyHeight - p.bodyTopBevel});
        this.tube.addCircle({r1:topDia - p.bodyTopBevel, r2:5.8, z:p.bodyHeight});
        this.geo = this.tube.createGeo(p.bodySubdiv, p.bodyKnurlNum, p.bodyKnurlDepth);
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh) {
            app.scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
        }
        this.getGeo();
        this.material = new THREE.MeshPhongMaterial({color: p.bodyColor, flatShading:true});
        this.mesh = new THREE.Mesh(this.geo, this.material);
        this.mesh.visible = !!p.bodyEnable;
        app.scene.add(this.mesh);
    }
}
class Skirt {
    constructor() {
        this.tube = new Tube();
        this.geo = null;
        this.mesh = null;
        this.material = null;
    }
    getGeo() {
        const p = paramCurrent.params;
        this.tube.clear();
        this.tube.addCircle({r1:(p.bodyBottomDiameter + p.skirtDiameter)*0.5, r2:5.8, z:-p.skirtHeight});
        this.tube.addCircle({r1:(p.bodyBottomDiameter + p.skirtDiameter)*0.5, r2:5.8, z:-p.skirtBevel});
        this.tube.addCircle({r1:(p.bodyBottomDiameter + p.skirtDiameter - p.skirtBevel * 2)*0.5, r2:5.8, z:0.0});
        this.geo = this.tube.createGeo(p.skirtSubdiv, 0, 0);
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh) {
            app.scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
        }
        this.getGeo();
        this.material = new THREE.MeshPhongMaterial({color: p.skirtColor, flatShading:true});
        this.mesh = new THREE.Mesh(this.geo, this.material);
        this.mesh.visible = !!p.skirtEnable;
        app.scene.add(this.mesh);
    }
}
class Pointer {
    constructor() {
        this.rect = new Rectangular();
        this.mesh = null;
        this.material = null;
        this.geo = new THREE.BufferGeometry();
    }
    getGeo() {
        const p = paramCurrent.params;
        this.rect.clear();
        const b = Math.min(p.pointerHeight, p.pointerBevel);
        const z0 = 0;
        const z1 = p.bodyHeight;
        const z2 = p.bodyHeight + Math.max(0, p.pointerHeight - b);
        const z3 = p.bodyHeight + p.pointerHeight;
        const y0 = p.bodyBottomDiameter*0.5 + p.pointerLength;
        const y1 = p.bodyBottomDiameter*p.bodyTopDiameter*0.01*0.5 + p.pointerLength;
        const y2 = y1 + (y1 - y0) * (z2 - z1) / (z1 - z0);
        const y3 = y1 + (y1 - y0) * (z3 - z1) / (z1 - z0) - b;
        this.rect.addRect({x1:-p.pointerWidth*0.5, y1:5.8, x2:p.pointerWidth*0.5, y2:y0, z:z0});
        this.rect.addRect({x1:-p.pointerWidth*0.5, y1:5.8, x2:p.pointerWidth*0.5, y2:y1, z:z1});
        this.rect.addRect({x1:-p.pointerWidth*0.5, y1:0, x2:p.pointerWidth*0.5, y2:y1, z:z1});
        this.rect.addRect({x1:-p.pointerWidth*0.5, y1:0, x2:p.pointerWidth*0.5, y2:y2, z:z2});
        this.rect.addRect({x1:-p.pointerWidth*0.5, y1:b, x2:p.pointerWidth*0.5, y2:y3, z:z3});
        this.geo = this.rect.createGeo();
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh) {
            app.scene.remove(this.mesh);
            this.mesh.geometry.dispose();
            this.mesh.material.dispose();
        }
        this.getGeo();
        this.material = new THREE.MeshPhongMaterial({color: p.bodyColor, flatShading:true});
        this.mesh = new THREE.Mesh(this.geo, this.material);
        this.mesh.visible = !!p.pointerEnable;
        app.scene.add(this.mesh);
    }
}
class App {
    constructor() {
        this.width = 480;
        this.height = 630;

    }
    editParam(event) {
//        console.log("editParam",event.id, event.value);
        const p = paramCurrent.params;
        switch(event.id) {
        case "shaftEnable":
            p.shaftEnable = event.value;
            app.partsShaft.update();
            break;
        case "shaftType":
            p.shaftType = event.value;
            app.partsShaft.update();
            break;
        case "shaftFineAdj":
            p.shaftFineAdj = event.value;
            app.partsShaft.update();
            break;
        case "shaftRotate":
            p.shaftRotate = event.value;
            app.partsShaft.update();
            app.rotate();
            break;
        case "topEnable":
            p.topEnable = event.value;
            app.partsTop.update();
            break;
        case "topSubdiv":
            p.topSubdiv = event.value;
            app.partsTop.update();
            break;
        case "topTopDiameter":
            p.topTopDiameter = event.value;
            app.partsTop.update();
            break;
        case "topBottomDiameter":
            p.topBottomDiameter = event.value;
            app.partsTop.update();
            break;
        case "topHeight":
            p.topHeight = event.value;
            app.partsTop.update();
            break;
        case "topColor":
            p.topColor = event.value;
            document.getElementById("topColorInput").value = p.topColor;
            app.partsTop.update();
            break;
        case "topColorInput":
            p.topColor = event.value;
            document.getElementById("topColor").value = p.topColor;
            app.partsTop.update();
            break;
        case "bodyEnable":
            p.bodyEnable = event.value;
            app.partsBody.update();
            break;
        case "bodySubdiv":
            p.bodySubdiv = event.value;
            app.partsBody.update();
            break;
        case "bodyTopDiameter":
            p.bodyTopDiameter = event.value;
            app.partsBody.update();
            app.partsTop.update();
            app.partsPointer.update();
            break;
        case "bodyTopBevel":
            p.bodyTopBevel = event.value;
            app.partsBody.update();
            break;
        case "bodyKnurlForm":
            p.bodyKnurlForm = event.value;
            app.partsBody.update();
            break;
        case "bodyKnurlNum":
            p.bodyKnurlNum = event.value;
            app.partsBody.update();
            break;
        case "bodyKnurlDepth":
            p.bodyKnurlDepth = event.value;
            app.partsBody.update();
            break;
        case "bodyKnurlWidth":
            p.bodyKnurlWidth = event.value;
            app.partsBody.update();
            break;
        case "bodyBottomDiameter":
            p.bodyBottomDiameter = event.value;
            app.partsTop.update();
            app.partsBody.update();
            app.partsSkirt.update();
            app.partsPointer.update();
            break;
        case "bodyHeight":
            p.bodyHeight = event.value;
            app.partsTop.update();
            app.partsBody.update();
            app.partsLid.update();
            app.partsSkirt.update();
            app.partsPointer.update();
            break;
        case "bodyColor":
            p.bodyColor = event.value;
            document.getElementById("bodyColorInput").value = p.bodyColor;
            app.partsBody.update();
            app.partsPointer.update();
            app.partsLid.update();
            app.partsShaft.update();
            break;
        case "bodyColorInput":
            p.bodyColor = event.value;
            document.getElementById("bodyColor").value = p.bodyColor;
            app.partsBody.update();
            app.partsPointer.update();
            app.partsLid.update();
            app.partsShaft.update();
            break;
        case "skirtEnable":
            p.skirtEnable = event.value;
            app.partsSkirt.update();
            break;
        case "skirtSubdiv":
            p.skirtSubdiv = event.value;
            app.partsSkirt.update();
            break;
        case "skirtHeight":
            p.skirtHeight = event.value;
            app.partsSkirt.update();
            break;
        case "skirtBevel":
            p.skirtBevel = event.value;
            app.partsSkirt.update();
            break;
        case "skirtDiameter": 
            p.skirtDiameter = event.value;
            app.partsSkirt.update();
            break;
        case "skirtColor":
            p.skirtColor = event.value;
            document.getElementById("skirtColorInput").value = p.skirtColor;
            app.partsSkirt.update();
            break;
        case "skirtColorInput":
            p.skirtColor = event.value;
            document.getElementById("skirtColor").value = p.skirtColor;
            app.partsSkirt.update();
            break;
        case "pointerEnable":
            p.pointerEnable = event.value;
            app.partsPointer.update();
            break;
        case "pointerLength":
            p.pointerLength = event.value;
            app.partsPointer.update();
            break;
        case "pointerWidth":
            p.pointerWidth = event.value;
            app.partsPointer.update();
            break;
        case "pointerHeight":
            p.pointerHeight = event.value;
            app.partsPointer.update();
            break;
        case "pointerBevel":
            p.pointerBevel = event.value;
            app.partsPointer.update();
            break;
        }
        this.rotate();
    }
    init() {
        console.log("init");
        const elmShaftType = document.getElementById("shaftType");
        for(let i=0; i < shaftFiles.length; ++i) {
            const op = document.createElement("option");
            op.innerText = shaftFiles[i];
            elmShaftType.append(op);
        }
        this.renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector("#canvas"),
        });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(this.width, this.height);

        this.scene = new THREE.Scene();

        this.camera = new THREE.PerspectiveCamera(
            45,
            this.width / this.height,
            1,
            10000
        );
        this.camera.position.set(50, 30, 80);
        this.camera.lookAt(0, 0, 0);
        this.rot = 0;

        const light1 = new THREE.AmbientLight(0xffffff, 0.1);
        this.scene.add(light1);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.8);
        light2.position.set(1, 1, 1);
        this.scene.add(light2);
        const light3 = new THREE.DirectionalLight(0xffffff, 0.5);
        light3.position.set(-1,-0.5,-1);
        this.scene.add(light3);

        this.material = new THREE.MeshPhongMaterial({color: 0xffffff, flatShading:true});
        this.material2 = new THREE.MeshPhongMaterial({color: 0x808080, flatShading:true});
    
        this.stlExporter = new STLExporter();

        this.partsShaft = new Shaft();
        this.partsShaft.update();
        this.partsTop = new Top();
        this.partsTop.update();
        this.partsLid = new Lid();
        this.partsLid.update();
        this.partsBody = new Body();
        this.partsBody.update();
        this.partsSkirt = new Skirt();
        this.partsSkirt.update();
        this.partsPointer = new Pointer();
        this.partsPointer.update();
        this.controls = new OrbitControls(this.camera, canvas);

        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.2;

//        const axesHelper = new THREE.AxesHelper(35);
//        axesHelper.position.set(0,0,0);
//        this.scene.add(axesHelper);
        document.getElementById('version').innerText = paramCurrent.version;

        const shaftdir = "./Shaft";


        this.loadSettings();
        this.tick();
    }
    loadSettings() {
        const def = JSON.parse(localStorage.getItem('defaultParam'));
        if(def && def.program == 'STLKnobDesigner' && def.version <= paramCurrent.version) {
            console.log(JSON.parse(localStorage.getItem('defaultParam')));
            paramCurrent.params = def.params;
        }
    }
    updateParams() {
        const p = paramCurrent.params;
        document.getElementById("shaftEnable").setValue(p.shaftEnable, true);
        document.getElementById("shaftType").value = p.shaftType;
        document.getElementById("shaftFineAdj").setValue(p.shaftFineAdj, true);
        document.getElementById("shaftRotate").setValue(p.shaftRotate, true);
        document.getElementById("topSubdiv").setValue(p.topSubdiv, true);
        document.getElementById("topTopDiameter").setValue(p.topTopDiameter, true);
        document.getElementById("topBottomDiameter").setValue(p.topBottomDiameter, true);
        document.getElementById("topHeight").setValue(p.topHeight, true);
        document.getElementById("topColor").value = document.getElementById("topColorInput").value = p.topColor;
        document.getElementById("bodySubdiv").setValue(p.bodySubdiv, true);
        document.getElementById("bodyTopDiameter").setValue(p.bodyTopDiameter, true);
        document.getElementById("bodyTopBevel").setValue(p.bodyTopBevel, true);
        document.getElementById("bodyBottomDiameter").setValue(p.bodyBottomDiameter, true);
        document.getElementById("bodyHeight").setValue(p.bodyHeight, true);
        document.getElementById("bodyKnurlForm").setValue(p.bodyKnurlForm, true);
        document.getElementById("bodyKnurlNum").setValue(p.bodyKnurlNum, true);
        document.getElementById("bodyKnurlDepth").setValue(p.bodyKnurlDepth, true);
        document.getElementById("bodyKnurlWidth").setValue(p.bodyKnurlWidth, true);
        document.getElementById("bodyColor").value = document.getElementById("bodyColorInput").value = p.bodyColor;
        document.getElementById("skirtSubdiv").setValue(p.skirtSubdiv, true);
        document.getElementById("skirtDiameter").setValue(p.skirtDiameter, true);
        document.getElementById("skirtBevel").setValue(p.skirtBevel, true);
        document.getElementById("skirtHeight").setValue(p.skirtHeight, true);
        document.getElementById("skirtColor").value = document.getElementById("skirtColorInput").value = p.skirtColor;
        document.getElementById("pointerLength").setValue(p.pointerLength, true);
        document.getElementById("pointerWidth").setValue(p.pointerWidth, true);
        document.getElementById("pointerHeight").setValue(p.pointerHeight, true);
        document.getElementById("pointerBevel").setValue(p.pointerBevel, true);
    }
    tick() {
        if(app.controls)
            app.controls.update();
        if(app.renderer)
            app.renderer.render(app.scene, app.camera);
    //  requestAnimationFrame(tick);
        setTimeout(app.tick.bind(app),50);
    }
    about() {
        document.getElementById("aboutpane").style.display='block';
    }
    rotate(event) {
        if(event)
            this.rot = event.value;
        const r = -this.rot * Math.PI / 180;
        this.partsTop.mesh.rotation.set(0,0,r);
        this.partsBody.mesh.rotation.set(0,0,r);
        this.partsSkirt.mesh.rotation.set(0,0,r);
        this.partsPointer.mesh.rotation.set(0,0,r);
        if(this.partsShaft.meshes[paramCurrent.params.shaftType])
            this.partsShaft.meshes[paramCurrent.params.shaftType].rotation.set(0,0,r + Math.PI * paramCurrent.params.shaftRotate / 180);
    }
    save() {
        console.log('app.save');
        const data = JSON.stringify(paramCurrent, null, 2);
        const link = document.createElement('a');
        const blob = new Blob([data], {type:'text/plain'});
        link.href=URL.createObjectURL(blob);
        link.download = "stlknob.json";
        link.click();
        URL.revokeObjectURL(link.href);
    }
    load() {
        console.log('app.load');
        const link = document.createElement('input');
        window.loadlink = link;
        link.type = 'file';
        link.click();
        link.onchange=()=>{
            const reader = new FileReader();
            reader.onload = (event)=>{
                const obj = JSON.parse(event.target.result);
                console.log(obj)
                if(obj.program != 'STLKnobDesigner'){
                    alert('Data Error');
                }
                else {
                    paramCurrent.params = obj.params;
                    app.updateParams();
                }
            }
            reader.readAsText(link.files[0]);
        }
    }
    saveDefault() {
        console.log(paramCurrent);
        if(confirm('Remember current settings as default?\n現在の設定をデフォルト値として記憶しますか?')) {
            console.log("app.saveDefault()");
            localStorage.setItem('defaultParam', JSON.stringify(paramCurrent));
            alert("Current settings are remembered as default.\n現在の設定がデフォルト値として記憶されました。");
        }
    }
    export() {
        console.log('app.export()');
        document.getElementById("knobrot").setValue(0, true);
        const data = this.stlExporter.parse(this.scene, false);
        const link = document.createElement('a');
        const blob = new Blob([data], {type:'text/plain'});
        link.href=URL.createObjectURL(blob);
        link.download = "knob.stl";
        link.click();
        URL.revokeObjectURL(link.href);
    }
}
window.clearSettings = () => {
    localStorage.clear();
    app.loadSettings();
    app.updateParams();
    app.partsShaft.update();
    app.partsTop.update();
    app.partsBody.update();
    app.partsSkirt.update();
    app.partsPointer.update();
    app.partsLid.update();
    console.log('clearSettings()');
}
window.addEventListener("DOMContentLoaded", ()=>{
    window.app = new App();
    window.paramDefault = paramDefault;
    window.paramCurrent = paramCurrent;
    window.editParam = app.editParam.bind(app);
    window.app.init();
    window.app.updateParams();
});

</script>
</body>
</html>