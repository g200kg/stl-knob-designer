<html>
<head>
<meta charset="utf-8" />
<title>STL Knob Designer</title>
<style>
html {
    margin:0;
    padding:0;
    background:#006;
    height:100%;
    font-size:14px;
}
body {
    margin:0;
    height:100%;
    padding:0;
    background:#222;
    color:#e0e0e0;
}
#header {
    margin:0;
    padding:0;
    display:flex;
    height:80px;
    position:relative;
    background:#445;
    color:#ccf;
    border:2px solid #445;
}
#header a {
    color:#ccf;
}
#title {
    padding:2px;
}
#subtitle {
    padding-left:20px;
    font-size:12px;
}
#logo {
    width:180px;
    height:80px;
}
h1 {
    margin:auto 12px;
    font-size:26px;
}
#menu {
    background:#666686;
    height:40px;
}
.cmdButton {
    margin:4px 4px;
    width: 160px;
    height: 32px;
    background:#ccd;
    font-size:14px;
}
td {
    font-size: 13.5px;
    background: #223;
    padding:0px 5px;
    text-align: center;
}
select {
    width: 150px;
}
canvas {
    width:100%;
    height:100%;
    background:#000;
}
#parampane {
    width:480px;
    overflow-y:scroll;
    overflow-x:hidden;
    margin:10px;
    border:1px solid #666666;
}
.content {
    position:relative;
    background:#556;
    margin:10px;
    width:500px;
}
table {
    margin:20px;
}
.param {
    vertical-align: middle;
    height:18px;
    width:60px;
}
.paramcolor {
    width:60px;
    height:20px;
    text-align: center;
    font-size:12px;
    background:#000;
    color:#fff;
    border:none;
}
#main {
    background:#445;
    width:1050px;
    height:calc(100% - 140px);
    margin:5px auto;
    display:flex;
    justify-content: center;
    position:relative;
    border:none;
    border:1px solid #778;
}
#knobrot {
    position:absolute;
    left:12px;
    bottom:12px;
    width:200px;
}
#aboutpane {
    display:none;
    position:absolute;
    left:50%;
    top:0;
    background:rgba(0,0,0,0.5);
    width:100%;
    height:100%;
    transform: translate(-50%, 0);
}
#about {
    position:relative;
    background:#ccf;
    width:80%;
    height:80%;
    margin:auto;
    top:20px;
    color:#1f243a;
    padding:20px;
    overflow-y: scroll;
}
#aboutcontent {
    color:#1f243a;
    background:#ccf;
}
#aboutcontent td {
    color:#000;
}
#aboutclose {
    position:absolute;
    right:20px;
    top:20px;
    width:120px;
    height:36px;
}
</style>

<!--<script src="https://code.jquery.com/jquery-3.7.0.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
<script src="js/jquery.gorilla-dropdown.min.js"></script>
<link rel="stylesheet" href="js/jquery.gorilla-dropdown.css">-->

<body>
<div id="header">
    <img id="logo" src="images/g200kg160x80.png"/>
    <div id="title">
        <h1>STL Knob Designer</h1>
        <div id="subtitle">
            <p style="margin:0px 40px">v <span id="version"></span> g200kg</p>
            <p style="margin:0px 40px">Repository : <a href="https://github.com/g200kg/stl-knob-designer" target="_blank">https://github.com/g200kg/stl-knob-designer</a> </p>
            <p style="position:absolute;right:10px;bottom:0;vertical-align:middle;height:20px"><label><input id="langen" type="radio" name="lang" onchange="app.setLocale('en')"/>English</label> | <label><input id="langja" type="radio" name="lang" onchange="app.setLocale('ja')"/>日本語</label></p>
        </div>
    </div>
</div>
<div id="menu">
    <button class="cmdButton" id="cmdExport" onclick="app.export()">Export as STL</button>
    <button class="cmdButton" id="cmdSave" onclick="app.save()">Save Param (JSON)</button>
    <button class="cmdButton" id="cmdLoad" onclick="app.load()">Load Param (JSON)</button>
    <button class="cmdButton" id="cmdSetDefault" onclick="app.setDefault()">Set Default</button>
    <button class="cmdButton" id="cmdAbout" onclick="app.about()">About</button>
</div>
<div id="main">
    <div class="content">
            <canvas id="canvas"></canvas>
            <webaudio-slider id="knobrot" defvalue="0" min="-145" max="145" oninput="app.rotate(this)"></webaudio-slider>
    </div>
    <div class="content" id="parampane">
        <table>
            <tr><td rowspan="4"><webaudio-switch id="shaftEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="4" id="lbShaft">SHAFT</td><td id="lbShaftType">Type</td><td colspan="2"><select id="shaftType" onchange="editParam(this)">
            </select></td></tr>
            <tr><td id="lbShaftFineAdj">FineAdjust(%)</td><td style="width:80px"><webaudio-knob id="shaftFineAdj" oninput="editParam(this)" min="-5" max="10" step="0.1"></webaudio-knob></td><td><webaudio-param link="shaftFineAdj" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbShaftRotate">Rotate(deg)</td><td><webaudio-knob id="shaftRotate" oninput="editParam(this)" min="-180" max="180" step="15"></webaudio-knob></td><td><webaudio-param link="shaftRotate" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbShaftHeight">Height(mm)</td><td><webaudio-knob id="shaftHeight" oninput="editParam(this)" min="10" max="20" step="0.1"></webaudio-knob></td><td><webaudio-param link="shaftHeight" fontSize="14"></webaudio-param></td></tr>

            <tr><td rowspan="7"><webaudio-switch id="capEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="7" id="lbCap">CAP</td><td id="lbCapType">Type</td><td colspan="2"><select id="capType" onchange="editParam(this)"><option>Cylinder</option><option>Sphere</option><option>Ring</option></td></tr>
            <tr><td id="lbCapSubdiv">Subdivide</td><td><webaudio-knob id="capSubdiv" oninput="editParam(this)" min="3" max="72" step="1"></webaudio-knob></td><td><webaudio-param link="capSubdiv" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbCapTopDiameter">TopDiameter(%)</td><td><webaudio-knob id="capTopDiameter" oninput="editParam(this)" min="0" max="100" step="1"></webaudio-knob></td><td><webaudio-param link="capTopDiameter" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbCapBottomDiameter">BottomDiameter(%)</td><td><webaudio-knob id="capBottomDiameter" oninput="editParam(this)" min="0" max="100" step="1"></webaudio-knob></td><td><webaudio-param link="capBottomDiameter" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbCapHeight">Height(mm)</td><td><webaudio-knob id="capHeight" oninput="editParam(this)" min="0" max="10" step="0.1"></webaudio-knob></td><td><webaudio-param link="capHeight" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbCapNotchWidth">NotchWidth(mm)</td><td><webaudio-knob id="capNotchWidth" oninput="editParam(this)" min="0.0" max="10" step="0.1"></webaudio-knob></td><td><webaudio-param link="capNotchWidth" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbCapColor">Color</td><td><input type="color" id="capColor" oninput="editParam(this)"/></td><td><input id="capColorInput" class="paramcolor" onchange="editParam(this)" style="font-size:14px"/></td></tr>

            <tr><td rowspan="10"><webaudio-switch id="bodyEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="10" id="lbBody">BODY</td><td id="lbBodySubdiv">Subdivide</td><td><webaudio-knob id="bodySubdiv" oninput="editParam(this)" min="3" max="180" step="1"></webaudio-knob></td><td><webaudio-param link="bodySubdiv" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbBodyTopDiameter">TopDiameter(%)</td><td><webaudio-knob id="bodyTopDiameter" oninput="editParam(this)" min="0" max="200" step="1"></webaudio-knob></td><td><webaudio-param link="bodyTopDiameter" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbBodyTopBevel">TopBevel(mm)</td><td><webaudio-knob id="bodyTopBevel" oninput="editParam(this)" min="0" max="5.0" step="0.1"></webaudio-knob></webaudio-knob></td><td><webaudio-param link="bodyTopBevel" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbBodyBottomDiameter">BottomDiameter(mm)</td><td><webaudio-knob id="bodyBottomDiameter" oninput="editParam(this)" min="10" max="50" step="0.1"></webaudio-knob></td><td><webaudio-param link="bodyBottomDiameter" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbBodyHeight">Height(mm)</td><td><webaudio-knob id="bodyHeight" oninput="editParam(this)" min="12" max="50" step="0.1"></webaudio-knob></td><td><webaudio-param link="bodyHeight" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbBodyKnurlForm">KnurlForm</td><td><webaudio-knob id="bodyKnurlForm" oninput="editParam(this)" min="0" max="2" step="1" tracking="abs" conv="['None','Sin','Sqr'][x]"></webaudio-knob></td><td><webaudio-param link="bodyKnurlForm" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbBodyKnurlNum">KnurlNum</td><td><webaudio-knob id="bodyKnurlNum" oninput="editParam(this)" min="0" max="36" step="1"></webaudio-knob></td><td><webaudio-param link="bodyKnurlNum" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbBodyKnurlDepth">KnurlDepth(mm)</td><td><webaudio-knob id="bodyKnurlDepth" oninput="editParam(this)" min="0" max="5" step="0.1"></webaudio-knob></td><td><webaudio-param link="bodyKnurlDepth" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbBodyKnurlWidth">KnurlWidth</td><td><webaudio-knob id="bodyKnurlWidth" oninput="editParam(this)" min="-5" max="5" step="0.1"></webaudio-knob></td><td><webaudio-param link="bodyKnurlWidth" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbBodyColor">Color</td><td><input type="color" id="bodyColor" oninput="editParam(this)"/></td><td><input id="bodyColorInput" class="paramcolor" onchange="editParam(this)" style="font-size:14px"/></td></tr>

            <tr><td rowspan="5"><webaudio-switch id="skirtEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="5" id="lbSkirt">SKIRT</td><td id="lbSkirtSubdiv">Subdivide</td><td><webaudio-knob id="skirtSubdiv" oninput="editParam(this)" min="3" max="72" step="1"></webaudio-knob></td><td><webaudio-param link="skirtSubdiv" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbSkirtDiameter">Diameter(mm)</td><td><webaudio-knob id="skirtDiameter" oninput="editParam(this)" min="0" max="10.0" step="0.1"></webaudio-knob></td><td><webaudio-param link="skirtDiameter" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbSkirtBevel">Bevel(mm)</td><td><webaudio-knob id="skirtBevel" oninput="editParam(this)" min="0" max="5.0" step="0.1"></webaudio-knob></td><td><webaudio-param link="skirtBevel" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbSkirtHeight">Height(mm)</td><td><webaudio-knob id="skirtHeight" oninput="editParam(this)" min="0" max="10" step="0.1"></webaudio-knob></td><td><webaudio-param link="skirtHeight" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbSkirtColor">Color</td><td><input type="color" id="skirtColor" oninput="editParam(this)"/></td><td><input id="skirtColorInput" class="paramcolor" onchange="editParam(this)" style="font-size:14px"/></td></tr>

            <tr><td rowspan="5"><webaudio-switch id="pointerEnable" value="1" onchange="editParam(this)"></webaudio-switch></td><td rowspan="5" id="lbPointer">POINTER</td><td id="lbPointerLength">Length(mm)</td><td><webaudio-knob id="pointerLength" oninput="editParam(this)" min="0" max="10" step="0.1"></webaudio-knob></td><td><webaudio-param link="pointerLength" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbPointerWidth">Width(mm)</td><td><webaudio-knob id="pointerWidth" oninput="editParam(this)" min="0.5" max="5.0" step="0.1"></webaudio-knob></td><td><webaudio-param link="pointerWidth" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbPointerHeight">Height(mm)</td><td><webaudio-knob id="pointerHeight" oninput="editParam(this)" min="-0.1" max="5.0" step="0.1"></webaudio-knob></td><td><webaudio-param link="pointerHeight" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbPointerBevel">Bevel(mm)</td><td><webaudio-knob id="pointerBevel" oninput="editParam(this)" min="0" max="5.0" step="0.1"></webaudio-knob></td><td><webaudio-param link="pointerBevel" fontSize="14"></webaudio-param></td></tr>
            <tr><td id="lbPointerColor">Color</td><td><input type="color" id="pointerColor" oninput="editParam(this)"/></td><td><input id="pointerColorInput" class="paramcolor" onchange="editParam(this)" style="font-size:14px"/></td></tr>
        </table>
    </div>
    <div id="aboutpane">
        <div id="about">
            <div>
                <div id="aboutcontent">
                    <h2>STL Knob Designer</h2>
                    <span id="abouttext"></span>
                    <hr/>
                    <img src="Shaft/Knob.png"/>
                    <hr/>
                    Repository : <a href="https://github.com/g200kg/stl-knob-designer" target="_blank">https://github.com/g200kg/stl-knob-designer</a>
                    <hr/>
                    g200kg
                </div>
            </div>
            <button id="aboutclose" onclick="document.getElementById('aboutpane').style.display='none'">Close</button>
        </div>
    </div>
</div>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module",
            "three/": "https://unpkg.com/three@0.153.0/",
            "three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/"
        }
    }
</script>
<script>
    WebAudioControlsOptions={
        knobDiameter:36,
        switchHeight:28,
        switchColors:"#e00;#223;#fcc",
        sliderWidth:180,
        paramWidth:60
    }
</script>
<script src="https://g200kg.github.io/webaudio-controls/webaudio-controls.js"></script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { STLLoader } from "three/examples/jsm/loaders/STLLoader";
import { STLExporter } from "three/examples/jsm/exporters/STLExporter.js";

//import { SUBTRACTION, Brush, Evaluator } from "three-bvh-csg";

const localeStr = {
    en:[
        {name:"abouttext", type:"text", val:
            "<p>This is a program that generates STL files of potentiometer-knobs for 3D printers. This program assumes that the potentiometer has a 6mm diameter and a knurled or D-shaped shaft.</p>"+
            "<p>This program assuming use with an FDM machine, and a slightly elastic filament such as PETG rather than PLA. You should more precisely adjust the shaft joint if you want to use PLA.</p>"+
            "<p>If your printer can output '3DBenchy' model fine without supports, you don't need to add supports. When placing the tip of the knob upwards on the platform, the base of the knob has an overhang at a 45 degree angle.</p>"+
            "<p>Depending on the printer model, settings and filament type, it may be necessary to fine-tune the fit with the shaft. For slicers such as 'Cura', the [Horizontal Expansion] and [Hole Horizontal Expansion] settings affect the size of the shaft-hole. You should adjust the size of the hole-shape in advance with these settings. Also the fitting to the shaft can be fine-tuned with the [SHAFT]-[FineAdject] parameter of this program.</p>"+
            "<p>The color setting is not reflected in the STL file, you can pause at a specific layer in the slicer and manually swap filaments.</p>"
        },
        {name:"cmdExport", type:"title", val:"Output the created knob as an STL file"},
        {name:"cmdSave", type:"title", val:"Save current settings as a JSON file"},
        {name:"cmdLoad", type:"title", val:"Load settings from a JSON file"},
        {name:"cmdSetDefault", type:"title", val:"Save current settings as default"},
        {name:"cmdAbout", type:"title", val:"Show program description"},
        {name:"lbShaftType", type:"title", val:"Fitting shape of the shaft, knurled or D shape"},
        {name:"lbShaftFineAdj", type:"title", val:"Fine adjustment of fitting with the shaft. Loose in the + direction and tight in the - direction."},
        {name:"lbShaftRotate", type:"title", val:"Default value for shaft rotation. Affects the orientation of the D-cut notch"},
        {name:"lbShaftHeight", type:"title", val:"Length from shaft-base to shaft tip. About 11mm is appropriate when screwing a potentiometer with a general 15mm long shaft to the panel."},
        {name:"lbCapType", type:"title", val:"Knob cap shape"},
        {name:"lbCapSubdiv", type:"title", val:"Number to divide the circumference of the knob cap"},
        {name:"lbCapTopDiameter", type:"title", val:"Top diameter ratio of knob cap"},
        {name:"lbCapBottomDiameter", type:"title", val:"Base diameter of knob cap"},
        {name:"lbCapHeight", type:"title", val:"Knob cap height"},
        {name:"lbCapNotchWidth", type:"title", val:"Notch in Knob Cap"},
        {name:"lbCapColor", type:"title", val:"Knob cap color"},
        {name:"lbBodySubdiv", type:"title", val:"Number to divide the circumference of the knob body"},
        {name:"lbBodyTopDiameter", type:"title", val:"Top diameter ratio of knob cap"},
        {name:"lbBodyBevel", type:"title", val:"Bevel of knob body top"},
        {name:"lbBodyBottomDiameter", type:"title", val:"Base diameter of knob body"},
        {name:"lbBodyHeight", type:"title", val:"Knob body height"},
        {name:"lbBodyKnurlForm", type:"title", val:"Groove shape added to the body"},
        {name:"lbBodyKnurlNum", type:"title", val:"Number of grooves on body"},
        {name:"lbBodyKnurlDepth", type:"title", val:"Depth of grooves on body"},
        {name:"lbBodyKnurlWidth", type:"title", val:"Width of grooves on body"},
        {name:"lbBodyColor", type:"title", val:"Body color"},
        {name:"lbSkirtSubdiv", type:"title", val:"Number to divide the circumference of the knob skirt"},
        {name:"lbSkirtDiameter", type:"title", val:"Base diameter of knob skirt"},
        {name:"lbSkirtBevel", type:"title", val:"Bevel of knob skirt"},
        {name:"lbSkirtHeight", type:"title", val:"Knob skirt height"},
        {name:"lbSkirtColor", type:"title", val:"Knob skirt color"},
        {name:"lbPointerLength", type:"title", val:"Pointer length"},
        {name:"lbPointerWidth", type:"title", val:"Pointer width"},
        {name:"lbPointerHeight", type:"title", val:"Pointer height"},
        {name:"lbPointerBevel", type:"title", val:"Bevel of pointer"},
        {name:"lbPointerColor", type:"title", val:"Pointer color"}
    ],
    ja:[
        {name:"abouttext", type:"text", val:
            "<p>これは 3D プリンタで造形可能なツマミの STL ファイルを生成するプログラムです。6mm 径の ローレット軸または D 型のシャフトを持つポテンショメータ用のツマミのデータを生成します。</p>"+
            "<p>FDM 機での使用を想定しており、フィラメントは PLA よりも PETG 等の多少の弾力性のある材料の方が簡単です。 PLA でも造形可能ですが、シャフトとの篏合の硬さの調整がシビアになります。</p>"+
            "<p>サポート無しで '3DBenchy' くらいがちゃんと造形できているのであれば、サポートの追加は必要ありません。プラットフォームにノブの先端を上向きに配置した時、ノブの底の部分にオーバーハングがありますが角度は 45 度になっています。</p>"+
            "<p>プリンタの機種やフィラメントの種類によって、シャフトとの篏合を微調整する必要があります。 Cura ベースのスライサーでは [水平展開 (Horizontal Expansion)] と [穴の水平展開 (Hole Horizontal Expansion)] の設定がシャフトが入る穴のサイズに影響します。</p>"+
            "<p>これらの設定で穴形状の造形時に誤差が無くなるようにあらかじめ補正した場合は [SHAFT]-[FineAdjust(%)]を 0 付近、補正しない場合は穴のサイズが少し小さくなるので +5.0 付近で調整してください。</p>"+
            "<p>色の設定は STL ファイルには反映されませんが、スライサーで CAP 部が始まるレイヤーを確認して、そこでプリンターを一時停止して、フィラメントを手動で入れ替えるなどの手段を取る事ができます。</p>"
        },
        {name:"cmdExport", type:"title", val:"作成したノブを STL ファイルとして出力"},
        {name:"cmdSave", type:"title", val:"現在の設定を JSON ファイルとして保存"},
        {name:"cmdLoad", type:"title", val:"JSON ファイルとして保存した設定をロード"},
        {name:"cmdSetDefault", type:"title", val:"現在の設定をデフォルトとして保存"},
        {name:"cmdAbout", type:"title", val:"プログラムの説明を表示"},
        {name:"lbShaftType", type:"title", val:"適合するシャフトの形状。ローレット軸または D 軸"},
        {name:"lbShaftFineAdj", type:"title", val:"シャフトとの篏合のかたさを微調整。+方向で緩く、-方向できつくなります。"},
        {name:"lbShaftRotate", type:"title", val:"シャフトの回転のデフォルト値。D 軸の切り欠きの方向に影響"},
        {name:"lbShaftHeight", type:"title", val:"Shaft-Baseからシャフトの先端までの長さ。一般的な 15mm 長シャフトのポテンショメータをパネルにねじ止めした場合 11mm 程度が適正"},
        {name:"lbCapType", type:"title", val:"ノブ先端部の形状"},
        {name:"lbCapSubdiv", type:"title", val:"ノブ先端部の円周の分割数"},
        {name:"lbCapTopDiameter", type:"title", val:"ノブ先端部の一番上の直径"},
        {name:"lbCapBottomDiameter", type:"title", val:"ノブ先端部の基本部直径"},
        {name:"lbCapHeight", type:"title", val:"ノブ先端部の高さ"},
        {name:"lbCapNotchWidth", type:"title", val:"ノブ先端部のポインター方向の切れ目"},
        {name:"lbCapColor", type:"title", val:"ノブ先端部の色"},
        {name:"lbBodySubdiv", type:"title", val:"ボディ部の円周の分割数"},
        {name:"lbBodyTopDiameter", type:"title", val:"ボディ部の上部の直径"},
        {name:"lbBodyBevel", type:"title", val:"ボディ部の上部の傾斜"},
        {name:"lbBodyBottomDiameter", type:"title", val:"ボディ部の一番下の直径"},
        {name:"lbBodyHeight", type:"title", val:"ボディ部の高さ"},
        {name:"lbBodyKnurlForm", type:"title", val:"ボディ部の凹凸の形状"},
        {name:"lbBodyKnurlNum", type:"title", val:"ボディ部の凹凸の数"},
        {name:"lbBodyKnurlDepth", type:"title", val:"ボディ部の凹凸の深さ"},
        {name:"lbBodyKnurlWidth", type:"title", val:"ボディ部の凹凸の幅"},
        {name:"lbBodyColor", type:"title", val:"ボディ部の色"},
        {name:"lbSkirtSubdiv", type:"title", val:"スカート部の円周の分割数"},
        {name:"lbSkirtDiameter", type:"title", val:"スカート部の円周の直径"},
        {name:"lbSkirtBevel", type:"title", val:"スカート部の上端の傾斜"},
        {name:"lbSkirtHeight", type:"title", val:"スカート部の高さ"},
        {name:"lbSkirtColor", type:"title", val:"スカート部の色"},
        {name:"lbPointerLength", type:"title", val:"ポインター部の長さ"},
        {name:"lbPointerWidth", type:"title", val:"ポインター部の幅"},
        {name:"lbPointerHeight", type:"title", val:"ポインター部の高さ"},
        {name:"lbPointerBevel", type:"title", val:"ポインター部の上端の傾斜"},
        {name:"lbPointerColor", type:"title", val:"ポインター部の色"}
    ]
};

const shaftFiles = [
    "Shaft_Knurled",
    "Shaft_D",
];
const paramDefault = {
    program: "STLKnobDesigner",
    version: "0.4.2",
    params: {
        shaftEnable: 1,
        shaftType: shaftFiles[0],
        shaftFineAdj: 0,
        shaftRotate: 0,
        shaftHeight: 10,
        capEnable: 1,
        capType: "Cylinder",
        capSubdiv: 36,
        capTopDiameter: 80,
        capBottomDiameter: 80,
        capHeight: 1.0,
        capNotchWidth: 0.5,
        capColor: "#ff0000",
        bodyEnable: 1,
        bodySubdiv: 72,
        bodyKnurlForm: 1,
        bodyKnurlNum: 12,
        bodyKnurlDepth: 0.6,
        bodyKnurlWidth: 0,
        bodyTopDiameter: 90,
        bodyTopBevel: 0.5,
        bodyBottomDiameter: 15.0,
        bodyHeight: 15.0,
        bodyColor: "#ffffff",
        skirtEnable: 1,
        skirtSubdiv: 36,
        skirtDiameter: 5.0,
        skirtBevel: 0.5,
        skirtHeight: 2.0,
        skirtColor: "#ffffff",
        pointerEnable: 1,
        pointerLength: 2.0,
        pointerWidth: 1.5,
        pointerHeight: 2.0,
        pointerBevel: 1.2,
        pointerColor: "#ffffff",
    }
};

const paramCurrent = Object.assign({}, JSON.parse(JSON.stringify(paramDefault)));
const canvasWidth = 480;
const canvasHeight = 600;

class Rect {
    constructor() {
        this.geo = new THREE.BufferGeometry();
        this.vtx = [];
    }
    clear() {
        this.vtx = [];
    }
    addRect(x1,y1,z1,  x2,y2,z2,  x3,y3,z3,  x4,y4,z4) {
        this.vtx.push(x1,y1,z1,  x2,y2,z2,  x3,y3,z3,  x4,y4,z4);
    }
    createGeo() {
        const indices = [];
        this.vertices = new Float32Array(this.vtx);
        indices.push(0, 2, 1);
        indices.push(0, 3, 2);
        let vb = 0;
        for(let l=12; l < this.vtx.length; l+=12, vb+=4) {
            indices.push(vb+0, vb+1, vb+4);
            indices.push(vb+1, vb+5, vb+4);
            indices.push(vb+1, vb+2, vb+5);
            indices.push(vb+2, vb+6, vb+5);
            indices.push(vb+2, vb+3, vb+6);
            indices.push(vb+3, vb+7, vb+6);
            indices.push(vb+3, vb+0, vb+7);
            indices.push(vb+0, vb+4, vb+7);
        }
        indices.push(vb+0, vb+1, vb+3);
        indices.push(vb+1, vb+2, vb+3);

        this.geo.setIndex(indices);
        this.geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.vtx), 3));
        this.geo.computeVertexNormals();
        return this.geo;
    }
}
class Tube {
    constructor() {
        this.geo = new THREE.BufferGeometry();
        this.layers = [];
    }
    clear() {
        this.layers = [];
    }
    wave(th) {
        const p = paramCurrent.params;
        switch(p.bodyKnurlForm) {
        case 0:
            return 0;
        case 1:
            return Math.pow((1+Math.cos(th))*0.5, Math.pow(2, -p.bodyKnurlWidth));
        case 2:
            const t = Math.pow((1+Math.cos(th))*0.5, Math.pow(2, -p.bodyKnurlWidth));
            if(t>=0.5) return 1;
            return 0;
        }
    }
    knurling(th) {
        return this.wave(th);
    }
    addCircle(layer) {
        this.layers.push(layer);
    }
    createGeo(divr, knurlNum, knurlDepth, knurlType) {
        this.geo = new THREE.BufferGeometry();
        const vtx = [];
        const indices = [];
        for(let l=0; l < this.layers.length; ++l) {
            const r1 = this.layers[l].r1;
            const r2 = this.layers[l].r2;
            const z = this.layers[l].z;
            for(let i = 0; i < divr; ++i) {
                const th = 2*Math.PI*i/divr;
                const kd = knurlDepth * this.knurling(th * knurlNum);
                const x = Math.sin(th);
                const y = Math.cos(th);
                vtx.push(x * (r1 + kd), y * (r1 + kd), z);
                vtx.push(x * r2, y * r2, z);
            }
        }
        this.vertices = new Float32Array(vtx);
        let vtxbase;
        const vtxmax = divr*2;
        for(let i = 0; i < divr; ++i){
            const j = i * 2;
            const j2 = (j+2)%vtxmax;
            const j3 = (j+3)%vtxmax;
            indices.push(j2, j+1, j);
            indices.push(j+1, j2, j3);
        }
        for(let l = 0; l < this.layers.length-1; ++l) {
            vtxbase = l*divr*2;
            for(let i = 0; i < divr; ++i) {
                const j = i * 2;
                const j2 = (j+2)%vtxmax;
                indices.push(j+vtxbase, j+divr*2+vtxbase, ((j+2)%vtxmax)+vtxbase);
                indices.push(((j+2)%vtxmax)+vtxbase, j+divr*2+vtxbase, j2+divr*2+vtxbase);
                indices.push(j+divr*2+1+vtxbase, j+1+vtxbase, ((j+2)%vtxmax)+1+vtxbase);
                indices.push(j+divr*2+1+vtxbase, ((j+2)%vtxmax)+1+vtxbase, j2+divr*2+1+vtxbase);
            }
        }
        vtxbase = (this.layers.length-1)*divr*2;
        for(let i = 0; i < divr; ++i){
            const j = i * 2 + vtxbase;
            const j2 = (j+2)%vtxmax + vtxbase;
            const j3 = (j+3)%vtxmax + vtxbase;
            indices.push(j, j+1, j2);
            indices.push(j3, j2, j+1);
        }
        this.geo.setIndex(indices);
        this.geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vtx), 3));
        this.geo.computeVertexNormals();
        return this.geo;
    }
}
class Shaft {
    constructor() {
        this.stlLoader = new STLLoader();
        this.meshes = [];
        this.mesh = [];
        this.material = new THREE.MeshPhongMaterial({color: "#fff", flatShading:true});
        for(let i = 0; i < shaftFiles.length; ++i) {
            this.stlLoader.load('Shaft/'+shaftFiles[i]+'.stl', (geoShaft)=> {
                this.meshes[shaftFiles[i]] = new THREE.Mesh(geoShaft, this.material);
                this.update();
            });
        }
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh.length) {
            app.scene.remove(this.mesh[0]);
            this.mesh = [];
        }
        if(p.shaftEnable) {
            this.mesh = [this.meshes[p.shaftType]];
            if(this.mesh.length && this.mesh[0]) {
                this.mesh[0].scale.set(1.0 + p.shaftFineAdj*0.01, 1.0 + p.shaftFineAdj*0.01, 1.0);
                app.scene.add(this.mesh[0]);
            }
        }
        app.rotate();
    }
}
class Cap {
    constructor(app) {
        this.app = app;
        this.tube = new Tube();
        this.geo = [];
        this.mesh = [];
        this.material = null;
    }
    getGeo() {
        const p = paramCurrent.params;
        const rb = p.bodyBottomDiameter * p.bodyTopDiameter*0.01 * p.capBottomDiameter * 0.005;
        switch(p.capType) {
            case "Cylinder": {
                this.rect = new Rect();
                const z1=p.bodyHeight;
                const z2=z1 + p.capHeight;
                const rb2=rb * p.capTopDiameter * 0.01;
                const nw = Math.min(p.capNotchWidth, rb2);

                for(let t = 0; t <= p.capSubdiv; ++t) {
                    const th = t/p.capSubdiv * 2 * Math.PI;
                    const sin = Math.sin(th);
                    const cos = Math.cos(th);
                    let r1x = rb*sin;
                    let r1y = rb*cos;
                    let r2x = rb2*sin;
                    let r2y = rb2*cos;
                    let r3x = nw*sin;
                    let r3y = nw*cos;
                    let z3 = z2;
                    if(t*4 < p.capSubdiv) {
                        r1x = Math.max(nw, r1x);
                        r1y = Math.sqrt(rb*rb - r1x*r1x);
                        r2x = Math.max(nw, r2x);
                        r2y = Math.sqrt(rb2*rb2 - r2x*r2x);
                        r3x = Math.max(nw, r3x);
                        r3y = Math.sqrt(nw*nw - r3x*r3x);
                    }
                    if(t*4 >= p.capSubdiv*3) {
                        r1x = Math.min(-nw, r1x);
                        r1y = Math.sqrt(rb*rb - r1x*r1x);
                        r2x = Math.min(-nw, r2x);
                        r2y = Math.sqrt(rb2*rb2 - r2x*r2x);
                        r3x = Math.min(-nw, r3x);
                        r3y = Math.sqrt(nw*nw - r3x*r3x);
                    }
                    this.rect.addRect(r1x, r1y, z1,   r2x, r2y, z2,    r3x,r3y,z2,    r3x,r3y,z1);
                }
                this.geo = [this.rect.createGeo()];
                break;
            }
            break;
        case "Sphere": {
                const rr = (rb*p.capTopDiameter*0.01)-rb;
                const zr = [
                    {z:p.bodyHeight, r:rb},
                    {z:p.bodyHeight + (p.capHeight * 0.259), r:rb + rr * (1-0.966)},
                    {z:p.bodyHeight + (p.capHeight * 0.5), r:rb + rr * (1-0.866)},
                    {z:p.bodyHeight + (p.capHeight * 0.707), r:rb + rr * (1-0.707)},
                    {z:p.bodyHeight + (p.capHeight * 0.866), r:rb + rr * 0.5},
                    {z:p.bodyHeight + (p.capHeight * 0.966), r:rb + rr * (1-0.259)},
                    {z:p.bodyHeight + p.capHeight, r:rb+rr},
                ];
                this.geo = [];
                for(let j = 0; j < zr.length - 1; ++j) {
                    this.rect = new Rect();
                    const z1 = zr[j].z;
                    const z2 = zr[j + 1].z;
                    const rb = zr[j].r;
                    const rb2 = zr[j + 1].r;
                    const nw = Math.min(p.capNotchWidth, rb2);

                    for(let t = 0; t <= p.capSubdiv; ++t) {
                        const th = t/p.capSubdiv * 2 * Math.PI;
                        const sin = Math.sin(th);
                        const cos = Math.cos(th);
                        let r1x = rb*sin;
                        let r1y = rb*cos;
                        let r2x = rb2*sin;
                        let r2y = rb2*cos;
                        let r3x = nw*sin;
                        let r3y = nw*cos;
                        if(th >= 0 && th < Math.PI*0.5) {
                            r1x = Math.max(nw, r1x);
                            r1y = Math.sqrt(rb*rb - r1x*r1x);
                            r2x = Math.max(nw, r2x);
                            r2y = Math.sqrt(rb2*rb2 - r2x*r2x);
                            r3x = Math.max(nw, r3x);
                            r3y = Math.sqrt(rb2*rb2 - r3x*r3x);
                        }
                        if(th >= Math.PI*1.5) {
                            r1x = Math.min(-nw, r1x);
                            r1y = Math.sqrt(rb*rb - r1x*r1x);
                            r2x = Math.min(-nw, r2x);
                            r2y = Math.sqrt(rb2*rb2 - r2x*r2x);
                            r3x = Math.min(-nw, r3x);
                            r3y = Math.sqrt(rb2*rb2 - r3x*r3x);
                        }
                        this.rect.addRect(r1x, r1y, z1,   r2x, r2y, z2,    r3x,r3y,z2,    r3x,r3y,z1);
                    }
                    this.geo.push(this.rect.createGeo());
                }
            }
            break;
        case "Ring": {
                this.rect = new Rect();
                const z1=p.bodyHeight;
                const z2=z1 + p.capHeight;
                const rb2=rb * p.capTopDiameter * 0.01;
                const nw = Math.min(p.capNotchWidth, rb2);
                for(let t = 0; t <= p.capSubdiv; ++t) {
                    const th = t/p.capSubdiv * 2 * Math.PI;
                    const sin = Math.sin(th);
                    const cos = Math.cos(th);
                    let r1x = rb*sin;
                    let r1y = rb*cos;
                    let r2x = rb2*sin;
                    let r2y = rb2*cos;
                    let r3x = nw*sin;
                    let r3y = nw*cos;
                    if(th >= 0 && th < Math.PI*0.5) {
                        r1x = Math.max(nw, r1x);
                        r1y = Math.sqrt(rb*rb - r1x*r1x);
                        r2x = Math.max(nw, r2x);
                        r2y = Math.sqrt(rb2*rb2 - r2x*r2x);
                        r3x = Math.max(nw, r3x);
                    }
                    if(th >= Math.PI*1.5) {
                        r1x = Math.min(-nw, r1x);
                        r1y = Math.sqrt(rb*rb - r1x*r1x);
                        r2x = Math.min(-nw, r2x);
                        r2y = Math.sqrt(rb2*rb2 - r2x*r2x);
                        r3x = Math.min(-nw, r3x);
                    }
                    this.rect.addRect(r1x, r1y, z1,   r1x, r1y, z2,    r2x,r2y,z2,    r2x,r2y,z1);
                }
                this.geo = [this.rect.createGeo()];
            }
            break;
        }
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh.length) {
            for(let i = 0; i < this.mesh.length; ++i) {
                app.scene.remove(this.mesh[i]);
                this.mesh[i].geometry.dispose();
            }
            this.material.dispose();
        }
        if(p.capEnable) {
            this.getGeo();
            this.material = new THREE.MeshPhongMaterial({color: p.capColor, flatShading:true});
            for(let i = 0; i < this.geo.length; ++i) {
                this.mesh[i] = new THREE.Mesh(this.geo[i], this.material);
                this.mesh[i].visible = !!p.capEnable;
                app.scene.add(this.mesh[i]);
            }
        }
    }
}
class Lid {
    constructor() {
        this.tube = new Tube();
        this.rect = new Rect();
        this.geo = [];
        this.mesh = [];
        this.material = null;
        this.subdiv = paramCurrent.params.bodySubdiv;
    }
    getGeo() {
        const p = paramCurrent.params;
        this.tube.clear();
        this.rect.clear();
        this.tube.addCircle({r1: 5.0, r2: 5.0, z: p.shaftHeight - 1.5});
        this.tube.addCircle({r1: 5.0, r2: 0.0, z: p.shaftHeight});
        this.tube.addCircle({r1: 5.0, r2: 0.0, z: p.bodyHeight});
        this.rect.clear();
        this.rect.addRect(
            0.6, 5.5, 0,
            0.6, p.bodyBottomDiameter*0.5, 0,
            -0.6, p.bodyBottomDiameter*0.5, 0,
            -0.6, 5.5, 0);
        this.rect.addRect(
            0.6, 4.0, 2.0,
            0.6, p.bodyBottomDiameter*0.5, 0.0,
            -0.6, p.bodyBottomDiameter*0.5, 0.0,
            -0.6, 4.0, 2.0);
        this.rect.addRect(
            0.6, 4.0, p.bodyHeight - p.bodyTopBevel,
            0.6, p.bodyBottomDiameter*p.bodyTopDiameter*0.005, p.bodyHeight - p.bodyTopBevel,
            -0.6, p.bodyBottomDiameter*p.bodyTopDiameter*0.005, p.bodyHeight - p.bodyTopBevel,
            -0.6, 4.0, p.bodyHeight - p.bodyTopBevel);
        this.geo[0] = this.tube.createGeo(24, 0, 0, 0);
        this.geo[1] = this.rect.createGeo();
        this.geo[2] = this.geo[1].clone();
        this.geo[3] = this.geo[1].clone();
        this.geo[4] = this.geo[1].clone();
        this.geo[2].rotateZ(Math.PI*0.5);
        this.geo[3].rotateZ(Math.PI*1.0);
        this.geo[4].rotateZ(Math.PI*1.5);
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh.length) {
            for(let i = 0; i < this.mesh.length; ++i) {
                app.scene.remove(this.mesh[i]);
                this.mesh[i].geometry.dispose();
            }
            this.material.dispose();
        }
        this.getGeo();
        this.material = new THREE.MeshPhongMaterial({color: p.bodyColor, flatShading:true});
        for(let i = 0; i < this.geo.length; ++i) {
            this.mesh[i] = new THREE.Mesh(this.geo[i], this.material);
            app.scene.add(this.mesh[i]);
        }
    }
}
class Body {
    constructor() {
        this.tube = new Tube();
        this.geo = null;
        this.mesh = [];
        this.material = null;
    }
    getGeo() {
        const p = paramCurrent.params;
        const topDia = (p.bodyBottomDiameter * p.bodyTopDiameter*0.01)*0.5;
        this.tube.clear();
        this.tube.addCircle({r1:p.bodyBottomDiameter*0.5, r2:5.8, z:0.0});
        this.tube.addCircle({r1:p.bodyBottomDiameter*0.5, r2:5.0, z:0.0});
        this.tube.addCircle({r1:topDia, r2:5.0, z:p.bodyHeight - p.bodyTopBevel});
        this.tube.addCircle({r1:topDia - p.bodyTopBevel, r2:5.0, z:p.bodyHeight});
        this.geo = this.tube.createGeo(p.bodySubdiv, p.bodyKnurlNum, p.bodyKnurlDepth);
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh.length) {
            app.scene.remove(this.mesh[0]);
            this.geo.dispose();
            this.material.dispose();
        }
        if(p.bodyEnable) {
            this.getGeo();
            this.material = new THREE.MeshPhongMaterial({color: p.bodyColor, flatShading:true});
            this.mesh = [new THREE.Mesh(this.geo, this.material)];
            app.scene.add(this.mesh[0]);
        }
    }
}
class Skirt {
    constructor() {
        this.tube = new Tube();
        this.geo = null;
        this.mesh = [];
        this.material = null;
    }
    getGeo() {
        const p = paramCurrent.params;
        const br = Math.max((p.bodyBottomDiameter + p.skirtDiameter)*0.5, 6);
        this.tube.clear();
        this.tube.addCircle({r1:br, r2:5.8, z:-p.skirtHeight});
        this.tube.addCircle({r1:br, r2:5.8, z:-p.skirtBevel});
        this.tube.addCircle({r1:br - p.skirtBevel, r2:5.8, z:0.0});
        this.geo = this.tube.createGeo(p.skirtSubdiv, 0, 0);
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh.length) {
            app.scene.remove(this.mesh[0]);
            this.geo.dispose();
            this.material.dispose();
        }
        if(p.skirtEnable) {
            this.getGeo();
            this.material = new THREE.MeshPhongMaterial({color: p.skirtColor, flatShading:true});
            this.mesh = [new THREE.Mesh(this.geo, this.material)];
            app.scene.add(this.mesh[0]);
        }
    }
}
class Pointer {
    constructor() {
        this.rect = new Rect();
        this.mesh = [];
        this.material = null;
        this.geo = new THREE.BufferGeometry();
    }
    getGeo() {
        const p = paramCurrent.params;
        this.rect.clear();
        const x1 = -p.pointerWidth * 0.5;
        const x2 = p.pointerWidth * 0.5;
        const b = Math.min(p.pointerBevel, p.bodyBottomDiameter * 0.5 * p.bodyTopDiameter * 0.01 * 0.5);
        const zb = p.bodyHeight + p.pointerHeight - p.pointerBevel;
        const yb = p.bodyBottomDiameter * 0.5 * p.bodyTopDiameter * 0.01 + p.pointerLength - p.pointerBevel;
        const z2 = p.bodyHeight + p.pointerHeight - p.pointerBevel;
        const yz = [
            {y1:5.0, y2:p.bodyBottomDiameter * 0.5, z1:0, z2:0},
            {y1:5.0, y2:p.bodyBottomDiameter * 0.5 + p.pointerLength, z1:p.pointerLength, z2:p.pointerLength},
            {y1:5.0, y2:p.bodyBottomDiameter * 0.5 * p.bodyTopDiameter * 0.01 + p.pointerLength, z1:p.bodyHeight, z2:zb},
            {y1:5.0, y2:p.bodyBottomDiameter * 0.5 * p.bodyTopDiameter * 0.01 + p.pointerLength - p.pointerBevel, z1:p.bodyHeight, z2:p.bodyHeight + p.pointerHeight},
            {y1:0, y2:0, z1:p.bodyHeight, z2:p.bodyHeight + p.pointerHeight},
        ];
        for(let t = 0; t < yz.length; ++t){
            this.rect.addRect(
                x2, yz[t].y1, yz[t].z1,
                x2, yz[t].y2, yz[t].z2,
                x1, yz[t].y2, yz[t].z2,
                x1, yz[t].y1, yz[t].z1,
            );
        }
        this.rect.addRect(
            p.pointerWidth*0.45,    -p.pointerWidth*0.25,   p.bodyHeight,
            p.pointerWidth*0.45,    -p.pointerWidth*0.25,   p.bodyHeight+p.pointerHeight,
            -p.pointerWidth*0.45,   -p.pointerWidth*0.25,   p.bodyHeight+p.pointerHeight,
            -p.pointerWidth*0.45,   -p.pointerWidth*0.25,   p.bodyHeight);
        this.rect.addRect(
            p.pointerWidth*0.25,    -p.pointerWidth*0.43,   p.bodyHeight,
            p.pointerWidth*0.25,    -p.pointerWidth*0.43,   p.bodyHeight+p.pointerHeight,
            -p.pointerWidth*0.25,   -p.pointerWidth*0.43,   p.bodyHeight+p.pointerHeight,
            -p.pointerWidth*0.25,   -p.pointerWidth*0.43,   p.bodyHeight);
        this.rect.addRect(
            0,  -p.pointerWidth*0.5,    p.bodyHeight,
            0,  -p.pointerWidth*0.5,    p.bodyHeight+p.pointerHeight,
            0,  -p.pointerWidth*0.5,    p.bodyHeight+p.pointerHeight,
            0,  -p.pointerWidth*0.5,    p.bodyHeight);
        this.geo = this.rect.createGeo();
    }
    update() {
        const p = paramCurrent.params;
        if(this.mesh.length) {
            app.scene.remove(this.mesh[0]);
            this.geo.dispose();
            this.material.dispose();
        }
        if(p.pointerEnable) {
            this.getGeo();
            this.material = new THREE.MeshPhongMaterial({color: p.pointerColor, flatShading:true});
            this.mesh = [new THREE.Mesh(this.geo, this.material)]
            app.scene.add(this.mesh[0]);
        }
    }
}
class App {
    constructor() {
    }
    editParam(event) {
//        console.log("editParam",event.id, event.value);
        const p = paramCurrent.params;
        switch(event.id) {
        case "shaftEnable":
            p.shaftEnable = event.value;
            app.partsShaft.update();
            break;
        case "shaftType":
            p.shaftType = event.value;
            app.partsShaft.update();
            break;
        case "shaftFineAdj":
            p.shaftFineAdj = event.value;
            app.partsShaft.update();
            break;
        case "shaftRotate":
            p.shaftRotate = event.value;
            app.partsShaft.update();
            app.rotate();
            break;
        case "shaftHeight":
            p.shaftHeight = event.value;
            app.partsLid.update();
            break;
        case "capEnable":
            p.capEnable = event.value;
            app.partsCap.update();
            break;
        case "capType":
            p.capType = event.value;
            app.partsCap.update();
            break;
        case "capSubdiv":
            p.capSubdiv = event.value;
            app.partsCap.update();
            break;
        case "capTopDiameter":
            p.capTopDiameter = event.value;
            app.partsCap.update();
            break;
        case "capBottomDiameter":
            p.capBottomDiameter = event.value;
            app.partsCap.update();
            break;
        case "capHeight":
            p.capHeight = event.value;
            app.partsCap.update();
            break;
        case "capNotchWidth":
            p.capNotchWidth = event.value;
            app.partsCap.update();
            break;
        case "capColor":
            p.capColor = event.value;
            document.getElementById("capColorInput").value = p.capColor;
            app.partsCap.update();
            break;
        case "capColorInput":
            p.capColor = event.value;
            document.getElementById("capColor").value = p.capColor;
            app.partsCap.update();
            break;
        case "bodyEnable":
            p.bodyEnable = event.value;
            app.partsBody.update();
            break;
        case "bodySubdiv":
            p.bodySubdiv = event.value;
            app.partsBody.update();
            break;
        case "bodyTopDiameter":
            p.bodyTopDiameter = event.value;
            app.partsBody.update();
            app.partsCap.update();
            app.partsPointer.update();
            app.partsLid.update();
            break;
        case "bodyTopBevel":
            p.bodyTopBevel = event.value;
            app.partsBody.update();
            app.partsLid.update();
            break;
        case "bodyKnurlForm":
            p.bodyKnurlForm = event.value;
            app.partsBody.update();
            break;
        case "bodyKnurlNum":
            p.bodyKnurlNum = event.value;
            app.partsBody.update();
            break;
        case "bodyKnurlDepth":
            p.bodyKnurlDepth = event.value;
            app.partsBody.update();
            break;
        case "bodyKnurlWidth":
            p.bodyKnurlWidth = event.value;
            app.partsBody.update();
            break;
        case "bodyBottomDiameter":
            p.bodyBottomDiameter = event.value;
            app.partsCap.update();
            app.partsLid.update();
            app.partsBody.update();
            app.partsSkirt.update();
            app.partsPointer.update();
            break;
        case "bodyHeight":
            p.bodyHeight = event.value;
            app.partsCap.update();
            app.partsBody.update();
            app.partsLid.update();
            app.partsSkirt.update();
            app.partsPointer.update();
            break;
        case "bodyColor":
            p.bodyColor = event.value;
            document.getElementById("bodyColorInput").value = p.bodyColor;
            app.partsBody.update();
            app.partsPointer.update();
            app.partsLid.update();
            app.partsShaft.update();
            break;
        case "bodyColorInput":
            p.bodyColor = event.value;
            document.getElementById("bodyColor").value = p.bodyColor;
            app.partsBody.update();
            app.partsPointer.update();
            app.partsLid.update();
            app.partsShaft.update();
            break;
        case "skirtEnable":
            p.skirtEnable = event.value;
            app.partsSkirt.update();
            break;
        case "skirtSubdiv":
            p.skirtSubdiv = event.value;
            app.partsSkirt.update();
            break;
        case "skirtHeight":
            p.skirtHeight = event.value;
            app.partsSkirt.update();
            app.partsPointer.update();
            break;
        case "skirtBevel":
            p.skirtBevel = event.value;
            app.partsSkirt.update();
            break;
        case "skirtDiameter": 
            p.skirtDiameter = event.value;
            app.partsSkirt.update();
            break;
        case "skirtColor":
            p.skirtColor = event.value;
            document.getElementById("skirtColorInput").value = p.skirtColor;
            app.partsSkirt.update();
            break;
        case "skirtColorInput":
            p.skirtColor = event.value;
            document.getElementById("skirtColor").value = p.skirtColor;
            app.partsSkirt.update();
            break;
        case "pointerEnable":
            p.pointerEnable = event.value;
            app.partsPointer.update();
            break;
        case "pointerLength":
            p.pointerLength = event.value;
            app.partsPointer.update();
            break;
        case "pointerWidth":
            p.pointerWidth = event.value;
            app.partsPointer.update();
            break;
        case "pointerHeight":
            p.pointerHeight = event.value;
            app.partsPointer.update();
            break;
        case "pointerBevel":
            p.pointerBevel = event.value;
            app.partsPointer.update();
            break;
        case "pointerColor":
            p.pointerColor = event.value;
            document.getElementById("pointerColorInput").value = p.pointerColor;
            app.partsPointer.update();
            break;
        case "pointerColorInput":
            p.pointerColor = event.value;
            document.getElementById("pointerColor").value = p.pointerColor;
            app.partsPointer.update();
            break;
        }
        this.rotate();
    }
    init() {
        console.log("init");
        this.setLocale();
        const elmShaftType = document.getElementById("shaftType");
        let opt = "";
        for(let i = 0; i < shaftFiles.length; ++i) {
//            opt += `<option data-imgsrc="Shaft/${shaftFiles[i]}.png">${shaftFiles[i]}</option>`;
            opt += `<option data-imgsrc="Shaft/${shaftFiles[i]}.png">${shaftFiles[i]}</option>`;
        }
        elmShaftType.innerHTML = opt;
//        $("#shaftType").gorillaDropdown({padding:0, width:200});

//        elmShaftType.innerHTML = ``;
//        for(let i=0; i < shaftFiles.length; ++i) {
//            const op = document.createElement("option");
//            op.innerHTML = `${shaftFiles[i]}<img src="Shaft/${shaftFiles[i].png}"/>`;
//            elmShaftType.append(op);
//        }
        this.renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById("canvas"),
        });
        console.log(canvas.width, canvas.height);
        console.log(document.getElementById("canvas").parentNode.clientHeight)
        this.renderer.setPixelRatio(window.devicePixelRatio);

        this.canvasNode = document.getElementById("canvas");
        this.renderer.setSize(this.canvasNode.parentNode.clientWidth, this.canvasNode.parentNode.clientHeight);
//        this.renderer.setSize(canvasWidth, canvasHeight);

        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
            45,
            canvasWidth / canvasHeight,
            1,
            10000
        );
        this.camera.position.set(50, 30, 80);
        this.camera.lookAt(0, 0, 0);
        this.rot = 0;
        this.resize();

        const light1 = new THREE.AmbientLight(0xffffff, 0.1);
        this.scene.add(light1);
        const light2 = new THREE.PointLight(0xffffff, 0.5);
        light2.position.set(12, 10, 60);
        this.scene.add(light2);
        const light3 = new THREE.DirectionalLight(0xffffff, 0.3);
        light3.position.set(-1,-0.5,-1);
        this.scene.add(light3);
        const light4 = new THREE.PointLight(0x8080ff, 1, 80);
        light4.position.set(-25,-15,35);
        this.scene.add(light4);

        this.material = new THREE.MeshPhongMaterial({color: 0xffffff, flatShading:true});
        this.material2 = new THREE.MeshPhongMaterial({color: 0x808080, flatShading:true});

        this.stlExporter = new STLExporter();

        this.partsShaft = new Shaft();
        this.partsShaft.update();
        this.partsCap = new Cap(this);
        this.partsCap.update();
        this.partsLid = new Lid();
        this.partsLid.update();
        this.partsBody = new Body();
        this.partsBody.update();
        this.partsSkirt = new Skirt();
        this.partsSkirt.update();
        this.partsPointer = new Pointer();
        this.partsPointer.update();
        this.controls = new OrbitControls(this.camera, canvas);

        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.2;
        document.getElementById('version').innerText = paramCurrent.version;

        const shaftdir = "./Shaft";
        this.loadSettings();
        this.tick();
    }
    setLocale(lang) {
        let strTab;
        if(!lang)
            lang = navigator.language;
        if(lang != "ja")
            lang = "en";
        strTab = localeStr[lang];
        document.getElementById("langen").checked = (lang == "en");
        document.getElementById("langja").checked = (lang == "ja");
        strTab.forEach((key)=>{
            const elm = document.getElementById(key.name);
            switch(key.type) {
            case "title":
                if(elm)
                    elm.title = key.val;
                break;
            case "text":
                if(elm)
                    elm.innerHTML = key.val;
                break;
            }
        });
    }
    loadSettings() {
        const def = JSON.parse(localStorage.getItem('defaultParam'));
        if(def && def.program == 'STLKnobDesigner' && def.version <= paramCurrent.version) {
            console.log(JSON.parse(localStorage.getItem('defaultParam')));
            paramCurrent.params = Object.assign(paramCurrent.params, def.params);
        }
    }
    updateParams() {
        const p = paramCurrent.params;
        document.getElementById("shaftEnable").setValue(p.shaftEnable, true);
        document.getElementById("shaftType").value = p.shaftType;
        document.getElementById("shaftFineAdj").setValue(p.shaftFineAdj, true);
        document.getElementById("shaftRotate").setValue(p.shaftRotate, true);
        document.getElementById("shaftHeight").setValue(p.shaftHeight, true);
        document.getElementById("capEnable").setValue(p.capEnable, true);
        document.getElementById("capType").value = p.capType;
        document.getElementById("capSubdiv").setValue(p.capSubdiv, true);
        document.getElementById("capTopDiameter").setValue(p.capTopDiameter, true);
        document.getElementById("capBottomDiameter").setValue(p.capBottomDiameter, true);
        document.getElementById("capHeight").setValue(p.capHeight, true);
        document.getElementById("capNotchWidth").setValue(p.capNotchWidth, true);
        document.getElementById("capColor").value = document.getElementById("capColorInput").value = p.capColor;
        document.getElementById("bodyEnable").setValue(p.bodyEnable, true);
        document.getElementById("bodySubdiv").setValue(p.bodySubdiv, true);
        document.getElementById("bodyTopDiameter").setValue(p.bodyTopDiameter, true);
        document.getElementById("bodyTopBevel").setValue(p.bodyTopBevel, true);
        document.getElementById("bodyBottomDiameter").setValue(p.bodyBottomDiameter, true);
        document.getElementById("bodyHeight").setValue(p.bodyHeight, true);
        document.getElementById("bodyKnurlForm").setValue(p.bodyKnurlForm, true);
        document.getElementById("bodyKnurlNum").setValue(p.bodyKnurlNum, true);
        document.getElementById("bodyKnurlDepth").setValue(p.bodyKnurlDepth, true);
        document.getElementById("bodyKnurlWidth").setValue(p.bodyKnurlWidth, true);
        document.getElementById("bodyColor").value = document.getElementById("bodyColorInput").value = p.bodyColor;
        document.getElementById("skirtEnable").setValue(p.skirtEnable, true);
        document.getElementById("skirtSubdiv").setValue(p.skirtSubdiv, true);
        document.getElementById("skirtDiameter").setValue(p.skirtDiameter, true);
        document.getElementById("skirtBevel").setValue(p.skirtBevel, true);
        document.getElementById("skirtHeight").setValue(p.skirtHeight, true);
        document.getElementById("skirtColor").value = document.getElementById("skirtColorInput").value = p.skirtColor;
        document.getElementById("pointerEnable").setValue(p.pointerEnable, true);
        document.getElementById("pointerLength").setValue(p.pointerLength, true);
        document.getElementById("pointerWidth").setValue(p.pointerWidth, true);
        document.getElementById("pointerHeight").setValue(p.pointerHeight, true);
        document.getElementById("pointerBevel").setValue(p.pointerBevel, true);
        document.getElementById("pointerColor").value = document.getElementById("pointerColorInput").value = p.pointerColor;
    }
    tick() {
        if(app.controls)
            app.controls.update();
        if(app.renderer)
            app.renderer.render(app.scene, app.camera);
    //  requestAnimationFrame(tick);
        setTimeout(app.tick.bind(app),50);
    }
    about() {
        document.getElementById("aboutpane").style.display='block';
    }
    rotate(event) {
        if(event)
            this.rot = event.value;
        const r = -this.rot * Math.PI / 180;
        if(this.partsCap)
            for(let i = 0; i < this.partsCap.mesh.length; ++i)
                this.partsCap.mesh[i].rotation.set(0,0,r);
        if(this.partsLid)
            for(let i = 0; i < this.partsLid.mesh.length; ++i)
                this.partsLid.mesh[i].rotation.set(0,0,r);
        if(this.partsBody)
            this.partsBody.mesh[0].rotation.set(0,0,r);
        if(this.partsSkirt)
            this.partsSkirt.mesh[0].rotation.set(0,0,r);
        if(this.partsPointer)
            this.partsPointer.mesh[0].rotation.set(0,0,r);
        if(this.partsShaft.meshes[paramCurrent.params.shaftType])
            this.partsShaft.meshes[paramCurrent.params.shaftType].rotation.set(0,0,r + Math.PI + Math.PI * paramCurrent.params.shaftRotate / 180);
    }
    save() {
        console.log('app.save');
        const data = JSON.stringify(paramCurrent, null, 2);
        const link = document.createElement('a');
        const blob = new Blob([data], {type:'text/plain'});
        link.href=URL.createObjectURL(blob);
        link.download = "stlknob.json";
        link.click();
        URL.revokeObjectURL(link.href);
    }
    load() {
        console.log('app.load');
        const link = document.createElement('input');
        window.loadlink = link;
        link.type = 'file';
        link.click();
        link.onchange=()=>{
            const reader = new FileReader();
            reader.onload = (event)=>{
                const obj = JSON.parse(event.target.result);
                console.log(obj)
                if(obj.program != 'STLKnobDesigner'){
                    alert('Data Error');
                }
                else {
                    paramCurrent.params = obj.params;
                    app.updateParams();
                }
            }
            reader.readAsText(link.files[0]);
        }
    }
    setDefault() {
        console.log(paramCurrent);
        if(confirm('Remember current settings as default?\n現在の設定をデフォルト値として記憶しますか?')) {
            console.log("app.saveDefault()");
            localStorage.setItem('defaultParam', JSON.stringify(paramCurrent));
            alert("Current settings are remembered as default.\n現在の設定がデフォルト値として記憶されました。");
        }
    }
    export() {
        console.log('app.export()');
        document.getElementById("knobrot").setValue(0, true);
        const data = this.stlExporter.parse(this.scene, false);
        const link = document.createElement('a');
        const blob = new Blob([data], {type:'text/plain'});
        link.href=URL.createObjectURL(blob);
        link.download = "knob.stl";
        link.click();
        URL.revokeObjectURL(link.href);
    }
    resize() {
        console.log("resize");
        const w = this.canvasNode.parentNode.clientWidth;
        const h = this.canvasNode.parentNode.clientHeight;
        this.renderer.setSize(w, h);
        this.camera.aspect = w / h;
        this.camera.updateProjectionMatrix();
    }
}
window.clearSettings = () => {
    localStorage.clear();
    app.loadSettings();
    app.updateParams();
    app.partsShaft.update();
    app.partsCap.update();
    app.partsBody.update();
    app.partsSkirt.update();
    app.partsPointer.update();
    app.partsLid.update();
    console.log('clearSettings()');
}
window.addEventListener("DOMContentLoaded", ()=>{
    window.app = new App();
    window.paramDefault = paramDefault;
    window.paramCurrent = paramCurrent;
    window.editParam = app.editParam.bind(app);
    window.app.init();
    window.app.updateParams();
});
window.addEventListener("resize", ()=> {
    window.app.resize();
});
</script>
</body>
</html>